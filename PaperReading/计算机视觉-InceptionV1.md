---
title: Inception V1 (GoogLeNet)
sitemap: true
date: 2018-08-02 21:16:20
categories: 计算机视觉
tags:
- 计算机视觉
- 网络结构
- 论文解读
---

**文章:** Going Deeper with Convolutions
**作者:** Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, Andrew Rabinovich
**备注:** Google, Inception V1


# 核心亮点

# 摘要

文章提出了一个深度卷积神经网络结构，并取名为Inception。该模型最主要的特点在于提高了网络内部计算资源的利用率。在保证计算负载不变的前提下，通过人工设计提升了网络的深度和宽度。该模型基于Hebbian原理和多尺度处理的intuition来提高性能。关于该模型的一个实例正是提交在ILSVRC14上的GoogLeNet，一个22层深的深度网络，主要针对分类和检测任务。

# 介绍

简要介绍了深度学习和神经网络技术近年来在图像分类和目标检测任务的发展。文章主要关注针对计算机视觉的高效深度神经网络，取名为Inception，名字来自于NIN。在文章中，“deep”具有两层含义：第一，指代文章新提出的Inception module，第二是指网络的深度。通常情况下，可以将Inception model视作NIN的“逻辑顶点”。

# 相关工作

略

# 动机和High Level的考虑

提高深度卷积网络最直接的方式就是增加它们的size，包括网络的深度（层数）和宽度（每层的神经元个数），这对于高质量的网络结构来说是ok的，尤其是在拥有大量优质数据的情况下。但是，这种方法存在这两个主要的缺点：
- 更大的size通常意味着更多的参数，这会使得网络更容易过拟合，尤其是在数据标签有限的情况下。由于获得大量优质数据具有一定难度，因此这往往会称为一个主要的瓶颈。
- 第二个缺点就是更大的size往往需要消耗更多的计算资源

文章认为解决以上问题的一个经济可行的办法是将全连接层置换成稀疏连接结构，甚至是在卷积内。

目前的硬件结构在面对非均匀分布的稀疏数据结构时，计算效率很低。

为此，文章希望找到一个新的结构，可以更高效的处理稀疏矩阵的运算。

文章通过多个实验验证了Inception模型在面对图像分类和检测问题时，可以取得十分好的效果。但是，对于Inception model是否能够成为其他领域任务的指导原则，还尚未有定论，需要更多的验证和实验才能说明。

# 框架细节

Inception模型的一个核心思想在于找到 **卷积网络中的最优局部稀疏结构可以在多大程度上被稠密组件近似和覆盖** 。需要注意，由于假设了平移不变性，因此本文的模型将从卷积模块中开始建立，本文所需要做的就是找到一个局部最优结构，然后将这些结构在空间上组合起来。

为了避免path-alignment问题，现在滤波器大小设值为1×1,3×3,和5×5。

由于pooling层的重要性，本文才采用了pooling层。

将上面的Inception模块叠加起来，形成一个整体的模型。

但是直接叠加会使得向量维度剧增，因此，通过1×1卷积来控制维度。

![](https://wx1.sinaimg.cn/large/d7b90c85ly1fvn6do3nmnj20un08y75k.jpg)

当max pooling层的stride为1时，并不会缩小输出的feature map的size，只会影响depth的值。

关于此结构的一个好处在于它可以提高神经元的个数，同时避免网络不受控制的提升计算机复杂度。


# GooLeNet(Inception V1)

![](https://wx1.sinaimg.cn/large/d7b90c85ly1fvn6q3t8hfj20j01x2qcf.jpg)

GoogLeNet(也叫做Inception V1)的网络结构图细节如下：

![](https://wx1.sinaimg.cn/large/d7b90c85ly1fvn98ano6mj20ps0f5778.jpg)

GoogLeNet网络结构明细表解析如下：

0、输入

原始输入图像为224x224x3，且都进行了零均值化的预处理操作（图像每个像素减去均值）。

1、第一层（卷积层）

使用7x7的卷积核（滑动步长2，padding为3），64通道，输出为112x112x64，卷积后进行ReLU操作
经过3x3的max pooling（步长为2），输出为((112 - 3+1)/2)+1=56，即56x56x64，再进行ReLU操作

2、第二层（卷积层）

使用3x3的卷积核（滑动步长为1，padding为1），192通道，输出为56x56x192，卷积后进行ReLU操作

经过3x3的max pooling（步长为2），输出为((56 - 3+1)/2)+1=28，即28x28x192，再进行ReLU操作

3a、第三层（Inception 3a层）

分为四个分支，采用不同尺度的卷积核来进行处理

（1）64个1x1的卷积核，然后RuLU，输出28x28x64

（2）96个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x96，然后进行ReLU计算，再进行128个3x3的卷积（padding为1），输出28x28x128

（3）16个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x16，进行ReLU计算后，再进行32个5x5的卷积（padding为2），输出28x28x32

（4）pool层，使用3x3的核（padding为1），输出28x28x192，然后进行32个1x1的卷积，输出28x28x32。
将四个结果进行连接，对这四部分输出结果的第三维并联，即64+128+32+32=256，最终输出28x28x256

3b、第三层（Inception 3b层）

（1）128个1x1的卷积核，然后RuLU，输出28x28x128

（2）128个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x128，进行ReLU，再进行192个3x3的卷积（padding为1），输出28x28x192

（3）32个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x32，进行ReLU计算后，再进行96个5x5的卷积（padding为2），输出28x28x96

（4）pool层，使用3x3的核（padding为1），输出28x28x256，然后进行64个1x1的卷积，输出28x28x64。

将四个结果进行连接，对这四部分输出结果的第三维并联，即128+192+96+64=480，最终输出输出为28x28x480

第四层（4a,4b,4c,4d,4e）、第五层（5a,5b）……，与3a、3b类似，在此就不再重复。


<span id = "简述一下 GoogLeNet 采用多个卷积核的原因">
# 简述一下 GoogLeNet 采用多个卷积核的原因
Inception Module这类结构非常看中模型在局部区域的拟合能力。它们认为：一张图像通常具有总体特征和细节特征这两类特征，一般小卷积核能够更好的捕捉一些细节特征，随着深层网络的小卷积不断计算下去，总体特征也会慢慢的被提炼出来，但是这样存在一个问题，那就是在如果只采用小卷积，那么网络结构的前段一般只有细节特征，后段才慢慢有一些总体特征，而我们希望这两方面的特征总是能够一起发挥作用，因此，Inception 模型考虑采用更多不同尺寸的卷积核来提取特征，并把这些特征连接起来，一起送到后面的网络中去计算，使得网络可以获取到更多的特征信息。

<span id = "Inception 中为什么使用 1×1 卷积层">
# Inception 中为什么使用 1×1 卷积层

关于Inception Module，有一种很直接的做法就是将1×1,3×3,5×5卷积和3×3 max pooling直接连接起来，如下面的左图所示，但是这样的话就有个问题，那就是计算量增长太快了。

![](https://wx1.sinaimg.cn/large/d7b90c85ly1fvn6do3nmnj20un08y75k.jpg)

为了解决这个问题，文章在3×3和5×5的卷积之前，3×3max pooling之后使用了1×1卷积，使其输出的feature map的depth降低了，从而达到了降维的效果，抑制的过快增长的计算量。

# 1×1卷积的作用是什么？

1x1卷积的主要目的是为了减少维度，降低计算量.

**1×1的卷积核，在一定程度上可以实现全连接层：**
具体的操作是，输入是224x224x3 的图像，假设经过变换之后最后一层是[7x7x512]的，那么传统的方法应该将其展平成为一个7x7x512长度的一层，然后做全连接层，假设全连接层为4096×1000层的（假设有1000个分类结果）。

那么用1×1卷积核怎么做呢，因为1×1卷积核相当于在不同channel之间做线性变换，所以：
- 先选择7×7的卷积核，输出层特征层数为4096层，这样得到一个[1×1×4096]层的
- 然后再选择用1×1卷积核，输出层数为1000层，这样得到一个[1×1×1000]层的

# 用卷积层代替全连接层的好处

这样做其实有非常多的好处，比如上面的例子中输入是224x224x3 的图像，如果此时图像变得更大了，变成384x384大小的了，那么一开始按照32作为步长来进行卷积操作，最后还按照这个网络结构能得到一个[6×6×1000]层的，那么前面那个[6×6]有什么用呢，这个代表每一个位置上，其属于1000个分类结果中的打分，所以这在图像分割等领域等领域有着非常重要的作用【之前一篇论文就是用的这种方法Fully Convolutional Networks for Semantic Segmentation】。

<span id = "Inception 中为什么使用全局平均池化层">
# Inception 中为什么使用全局平均池化层

最主要的作用就是大大降低了特征图谱的维度, 使得模型的参数量大大减少, 参数量的减少从另一方面来说相对于对网络模型的复杂度做了正则化, 从而在一定程度上可以防止网络模型出现过拟合问题.

<span id = "为什么使用侧枝">
# 为什么使用侧枝
为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度（辅助分类器）。辅助分类器是将中间某一层的输出用作分类，并按一个较小的权重（0.3）加到最终分类结果中，这样相当于做了模型融合，同时给网络增加了反向传播的梯度信号，也提供了额外的正则化，对于整个网络的训练很有裨益。而在实际测试的时候，这两个额外的softmax会被去掉。也就是说在测试的时候，只会用最后的softmax结果作为分类依据。

当时Inception网络还是太深了，不好训练，因此网络中还加了两个侧枝，通过中间层的feature map，来得到预测结果（有了ResNet的shortcut以后，这种侧枝用的比较少了）。

<span id = "GoogLeNet 在哪些地方使用了全连接层">
# GoogLeNet 在哪些地方使用了全连接层

在两个侧枝使用了卷积+FC+FC+SoftmaxActivation的结构，在最后一层使用了全局平均池化+FC+SoftmaxActivation的结构。
